= TP5 : Les Interruption
Par Martelet Curtis
:sectnums:
:partnums:
:hardbreaks:
:toc:
:doctype: book

== Introduction aux interruptions.

=== Interruptions Externes.

Avant tout, ces TP ont été réalisé sur une carte microcontrôleur _STM 32L152C-Discovery_.

Une interruption est une fonction électronique du microcontrôleur.
A la différence d'une fonction que l'on programme, une interruption est conçu pour que l'on ait pas à attendre pour qu'elle soit effective.

Pour débuter, nous souhaitons piloter les LEDs *PB6* et *PB7* de la carte à l'aide du bouton *PB0*. 
On utilisera une interruption pour réaliser cette fonction.

On doit réaliser le changement d'état des LEDs sur le front montant et descendant de *PB0*.

A l'aide du registre du microcontrôleur (stm32l1xx.h), on trouve que c'est `EXTI_Trigger` qui défini l'activation de l'interruption en fonction du front que l'on veut : 
Front Descendant : EXTI_Trigger_Falling.
Front Montant : EXTI_Trigger_Rising.
Front Montant/Descendant : EXTI_Trigger_Rising_Falling.

On utilise la fonction IRQ_EXTI0_Config() pour configurer l'interruption :
[source,c]
----
void IRQ_EXTI0_Config()
{
    // Configure GPIO pour l'Interrupteur
    /* Activer GPIOA */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);

    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode = GPIO_Mode_IN;
    gpio_a.GPIO_Pin = GPIO_Pin_0; // Pin 0
    GPIO_Init(GPIOA,&gpio_a);

    /* Activer SYSCFG sur APB2
     * pour permettre l'utilisation des interruptions externes */
    RCC_APB2PeriphClockCmd (RCC_APB2Periph_SYSCFG,ENABLE);
    /* Declarer PA0 comme source d'interruption */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);
    /* Param. des signaux qui déclencheront l'appel de EXTI0_IRQHandler()
     * autrement dit on paramètre les signaux associes a la "ligne 0"
     * ici : sur front montant & descendant ("EXTI_Trigger_Rising_Falling")     */
    EXTI_InitTypeDef EXTI0_params;
    EXTI_StructInit(&EXTI0_params);
    EXTI0_params.EXTI_Line = EXTI_Line0;
    EXTI0_params.EXTI_LineCmd = ENABLE;
    EXTI0_params.EXTI_Trigger = EXTI_Trigger_Rising_Falling;

    EXTI_Init(&EXTI0_params);

    /* Activer l'interruption dans le NVIC */
    NVIC_InitTypeDef nvic;
    NVIC_Init(&nvic);
    nvic.NVIC_IRQChannel = EXTI0_IRQn;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
----

Une fois l'interruption configurée, il s'agit maintenant de définir ce qu'il se passera une fois celle-ci en action.
La fonction `EXTI0_IRQHandler()` est faite pour cela : elle est appelée quand l'interruption a lieu.

On souhaite donc inverser l'état d'une LED que l'on aura choisie. `GPIO_ToggleBits` est la fonction du GPIO qui permet d'inverser l'état d'un pin. Il est configuré fonction du coté (A ou B) et de son numéro.
[source,c]
----
// callback pour l'interruption externe EXTI0_IRQ
void EXTI0_IRQHandler(void) // Le code a executer quand il y a interruption.
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET) //Permet de faire une seule fois l'interruption au lieu de la répéter.
    {
        /* Clear the EXTI line 0 pending bit (enlève le flag) */
        EXTI_ClearITPendingBit(EXTI_Line0);
        GPIO_ToggleBits(GPIOB,GPIO_Pin_7); // Inverse état du pin 7 du coté B.
        GPIO_ToggleBits(GPIOB,GPIO_Pin_6); // Inverse état du pin 6 du coté B.
    }
}
----
Ici, le if évite que l'interruption se réalise plusieurs fois d'affilé, par exemple dans le cas du rebond d'un bouton.

Avec cette interruption, on inversera les états des LEDs PB6 et PB7 sur la pression et la relève du bouton.

Pour que les états des LEDs soient inversés l'un par rapport à l'autre, il suffit de définir l'état de base d'une des LEDs comme étant allumé :
on ajoute, avant la boucle du main, la fonction `GPIO_SetBits` qui se définie comme `GPIO_ToggleBits`. Cette fonction "set" à 1 le pin configuré, ce qui revient à alimenter la LED.

La fonction main de cet exercice devrait donc ressembler à cela :
[source,c]
.Fonction Main
----
int main(void)
{
    // # LED sur PB7 et PB6
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT; // Sortie tout-ou-rien
    gpio_b.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_6; // Pin choisi : 7 et 6
    GPIO_Init(GPIOB,&gpio_b);
    /* allumer la LED*/
    GPIO_SetBits(GPIOB,GPIO_Pin_7); // Set à 1 le pin 7 du coté B. La LED est allumée.
    // configuration de l'interruption
    IRQ_EXTI0_Config();

    while(1) {
        // Rien car on attend l'interruption
    }
}
----

Voir l'<<annexe,annexe>> pour le code entier.

=== Interruptions Périodique

Si le premier exercice ordonnait une interruption sur l'appuie d'un bouton (donc une source extérieure), ce second exercice se basera sur l'horloge du microcontrôleur pour ordonner l'interruption.

On souhaite faire clignoter la LED toutes les 500ms.
On va utiliser le Timer 2 de la carte pour mesurer ce temps.

[source,c]
------
void TIM2_IRQ_Config()
{
    /*Activer TIM2 sur APB1 */  
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    TIM_TimeBaseInitTypeDef timer_2;
    TIM_TimeBaseStructInit(&timer_2);
    timer_2.TIM_Prescaler = 16000-1;
    timer_2.TIM_Period = 500-1;
    TIM_TimeBaseInit(TIM2,&timer_2);
    TIM_SetCounter(TIM2,0);
    TIM_Cmd(TIM2, ENABLE); // Active le Timer

    /* Associer une interruption a TIM2 */
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

    NVIC_InitTypeDef nvic;
    /* Configuration de l'interruption */
    nvic.NVIC_IRQChannel = TIM2_IRQn;
    nvic.NVIC_IRQChannelPreemptionPriority = 0; 
    nvic.NVIC_IRQChannelSubPriority = 1;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
------

Le code de l'interruption est identique à celle des interruptions extérieures, au détail près qu'elle s'appelle `TIM2_IRQHandler`.

==== Changement de Fréquence

On nous demande cette fois-ci une fréquence de 44kHz. On choisi cette fois-ci de mettre le prescaler à 0.
Fhorloge = 44 kHz ; CPU = 16 MHz.

Thorloge = (TIM_Period+1)*(TIM_Prescaler+1)/16e6
1/44e3 = TIM_Period/16e6 <=> TIM_Period = 16e6/44e3 = 363.6 (on arrondira au supérieur)

Une fois reconfiguré, on observe sur l'oscilloscope que la fréquence observée est la moitié de la fréquence prévue, à cause du fonctionnement de l'horloge


=== Le DAC
Le DAC (ou Digital to Analogic Convertor) est utilisé pour transformer une valeur de la carte en une tension analogique.
Selon le nombre de bit alloué au convertisseur, 

== Générer un courant sinusoïdal

Maintenant que l'on comprend comment le DAC fonctionne, on veut s'en servir pour générer une tension sinusoïdale sur le pin *PA4* de la carte.
Malheureusement, le microcontrôleur n'est pas capable de faire par lui même ce signal, c'est pourquoi nous allons l'aider en calculant les valeurs qu'il générera.

=== Le Sinus

Pour réaliser le sinus, nous avons tout d'abord besoin de la bibliothèque `math`. Sans elle, le programme ne sait pas le calculer. 

On stockera les valeurs du sinus dans un tableau que l'on définira à l'aide de la fonction `malloc`.
Malloc permet d'allouer à une variable un espace qui sera calculé en fonction du type de variable présente dedans :
`Tension = malloc(100*sizeof(float));`
Tension fait maintenant la taille de 100 valeurs du type float.

Les préparations maintenant faites, il faut maintenant calculer le sinus.

L'équation du sinus est :
Tension = 511 * sin(2*3.14159*k/100) + 2047;
où k est un incrément qui ira de 0 à 99 (100 valeurs).

Nous avons donc dans le main le calcul du sinus :
[source,c]
------
#include <math.h>

int main()
{
    float* Tension;
    Tension = malloc(100*sizeof(float));
    for(int k=0;k<100;k++)
    {
        Tension[k] = 511 * sin(2*3.14159*k/100) + 2047;
    }
}
------
Le microcontrôleur n'est pas capable de générer une tension négative, et sa valeur maximale est 3V.
On choisi donc de décaler la valeur moyenne du sinus de 1.5V. Ainsi, la valeur max est 3V et ma valeur minimale est 0V.

Le convertisseur analogique/numérique de la carte fonctionne sur 12 bits : 2^12 = 4096 valeurs.
Donc pour 3V, le convertisseur est égal à 4095 ; pour 1.5V (la valeur moyenne), 2047 ; et pour 0V, 0.

* La valeur minimale du sinus est donc :
2047 - 511 = *1536*, ce qui donne une tension en sortie du convertisseur de *1.25V*.

* La valeur minimale du sinus est donc :
2047 + 511 = *2558*, ce qui donne une tension en sortie du convertisseur de *1.87V*.

J'ai utilisé un produit en croix pour convertir les valeurs du convertisseurs en tension.


....
k = linspace(0,99,100000);
y = 0.374267578*sin(pi*k*2/100) + 1.5

min(y)
max(y)

plot(k,y)
xlabel('k')
ylabel('Tension')
title("Tension en sortie du convertisseur")
axis([0 99 0 3])
....

=== DAC & Sinus

Maintenant que le sinus est calculé et stocké dans la variable _Tension_, il est temps de ré-employer le code du précédent exercice : le `DCA1` et `TIM2`.

Nous n'avons pas besoin de toucher à la configuration. Le préscaleur (_timer_2.TIM_Prescaler_) et la période (_timer_2.TIM_Period_) restent les mêmes puisque l'on garde la fréquence de 440Hz.

Il est nécessaire de déclarer _Tension_ en variable globale : ainsi, ses valeurs pourront être utilisée dans l'interruption. Son incrémenteur (que l'on appellera _n_) sera également déclarée en variable globale.

La seule partie qui change est l'interruption en elle même :
[source,c]
------
void TIM2_IRQHandler() {
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);  // Remise à 0
        GPIO_ToggleBits(GPIOB, GPIO_Pin_7); // Débugage (vérifier que l'interruption a lieu)
        DAC1_Set(Tension[n%100]); // Converti la valeur en tension 
        // On ne dépasse pas 99 valeurs : à n = 100, n%100 = 0
        n++; // Incrémentation
    }
}
------

=== Écoute au Casque

Il est temps de brancher un casque à notre microcontrôleur. Cependant, ce dernier fonctionne avec des tensions comprises entre -1.5V et 1.5V.
Comme dit précédemment, la carte n'est pas capable de générer ces signaux. 
En réalisant un pont diviseur de tension et en y ajoutant un condensateur, on peut abaisser la tension moyenne de 1.5V à 0V.
Ainsi, on peut brancher le casque au microcontrôleur.

Une fois que l'on branche un casque sur le circuit, le son entendu n'est pas un DO, mais une note plus aiguë. 
Cela s'explique par le casque qui a besoin qu'on l'attaque avec une tension supérieure à celle fournie en sortie du condensateur. 
Ce manque de tension provoque une perturbation du signal généré par la carte, et donc crée des fréquences parasites qui perturbent l'écoute :
Le son entendu est plus aiguë que ce que l'on devrait avoir.

En mettant un montage suiveur entre le condensateur et le casque, l'AOP joue le role d'une alimentation qui va fournir un signal de meilleur qualité au casque, permettant d'entendre le DO.


== Le Mini-Synthétiseur

Dans un premier temps,  l'on modifie la fréquence du DAC sur l'appuie du bouton *PA0*. 
Chacune de ces fréquences correspondent à une note de musique. Le changement de fréquence modifiera le son produit.
[cols="2b,^,^,^,^,^,^,^,^"]
|===
|Note|Do|Re|Mi|Fa|Sol|La|Si|Do
|Fréquence|262|294|330|350|392|440|494|524
|Valeur DAC|611|544|484|458|408|363|323|306
|===

Ces valeurs sont initialisée dans une variable nommée _note_periode_.
[source,c]
------
unsigned int note_periode[8] = {611,544,484,458,408,363,323,306};
------

Pour générer 



== Mini Projet : Filtrage Numérique d'un Signal

Cette dernière partie du TP réutilisera plusieurs des fonctions du Synthétiseur, 


==== Get_Adc_quickly
Cette fonction est utilisée pour 
[source,C]
----
uint16_t Get_Adc_Quickly() {
    ADC1->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    while((ADC1->SR & ADC_FLAG_EOC) == 0) ;
    return (uint16_t) ADC1->DR;
}
----

#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
__IO uint32_t CR2;          /*!< ADC control register 2,                      Address offset: 0x08 */
__IO uint32_t SR;           /*!< ADC status register,                         Address offset: 0x00 */
__IO uint32_t DR;           /*!< ADC regular data register,                   Address offset: 0x58 */
#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!< Start Conversion of regular channels */
#define ADC_FLAG_EOC                               ((uint16_t)0x0002)

[%header,cols=",^1,2"]
|===
|Nom|Offset de l'adresse|Registre
|CR2|0x08|ADC control register 2
|SR|0x00|ADC status register
|DR|0x58|ADC regular data register
|===

==== DAC1_Set_Quickly
Cette fonction sert à 

Diminuer adc revient à diminuer le volume en sortie

[source,C]
----
void DAC1_Set_Quickly(uint16_t value) {
	static __IO uint32_t tmp = (uint32_t)DAC_BASE + (uint32_t)0x00000008 + DAC_Align_12b_R;
	*(__IO uint32_t *) tmp = value;
}
----

#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
#define DAC_Align_12b_R                    ((uint32_t)0x00000000)



== Annexe [[id,annexe]]
[source,c]
.Exercice 1
------
#include "stm32l1xx.h"

void IRQ_EXTI0_Config();

int main(void)
{
    // # LED sur PB7
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    /* Configurer PB7 comme sortie tout-ou-rien */
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT;
    gpio_b.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_6;
    GPIO_Init(GPIOB,&gpio_b);
    /* allumer la LED*/
    GPIO_SetBits(GPIOB,GPIO_Pin_7);
    // configuration de l'interruption
    IRQ_EXTI0_Config();

    while(1) {
    }
}

// callback pour l'interruption externe EXTI0_IRQ
void EXTI0_IRQHandler(void) // Le code a executer quand il y a interruption.
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET) // Permet de faire une seule fois l'interruption au lieu de la répéter.
    {
        /* Clear the EXTI line 0 pending bit (enlève le flag) */
        EXTI_ClearITPendingBit(EXTI_Line0);
        GPIO_ToggleBits(GPIOB,GPIO_Pin_7); // Inverse état du pin 7
        GPIO_ToggleBits(GPIOB,GPIO_Pin_6); // Inverse état du pin 6
    }
}

// ### EXTI0 sur PA0
// Configuration
void IRQ_EXTI0_Config()
{
    // # Interrupteur
    /* Activer GPIOA sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
    /* Configurer PB7 comme entree tout-ou-rien */
    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode = GPIO_Mode_IN;
    gpio_a.GPIO_Pin = GPIO_Pin_0;
    GPIO_Init(GPIOA,&gpio_a);

    /* Activer SYSCFG sur APB2
     * pour permettre l'utilisation des interruptions externes */
    RCC_APB2PeriphClockCmd (RCC_APB2Periph_SYSCFG,ENABLE);
    /* Declarer PA0 comme source d'interruption */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);
    /* Param. des signaux qui declencheront l'appel de EXTI0_IRQHandler()
     * autrement dit on parametre les signaux associes a la "ligne 0"
     * ici : sur front montant ("Trigger_Rising")
     */
    EXTI_InitTypeDef EXTI0_params;
    EXTI_StructInit(&EXTI0_params);
    EXTI0_params.EXTI_Line = EXTI_Line0;
    EXTI0_params.EXTI_LineCmd = ENABLE;
    EXTI0_params.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
// Front Descendant : EXTI_Trigger_Falling
// Front Montant : EXTI_Trigger_Rising
// Front : EXTI_Trigger_Rising_Falling

    EXTI_Init(&EXTI0_params);

    /* Activer l'interruption dans le NVIC */
    NVIC_InitTypeDef nvic;
    NVIC_Init(&nvic);
    nvic.NVIC_IRQChannel = EXTI0_IRQn;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
------