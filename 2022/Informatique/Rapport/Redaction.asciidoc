= TP5 : Les Interruption
Par Martelet Curtis
:sectnums:
:partnums:
:hardbreaks:
:toc:

<<<

== Introduction aux interruptions.

=== Interruptions Externes.

Avant tout, ces TP ont été réalisé sur une carte microcontrôleur _STM 32L152C-Discovery_.

Une interruption est une fonction électronique du microcontrôleur.
A la différence d'une fonction que l'on programme, une interruption est conçu pour que l'on ait pas à attendre.

Pour débuter, nous souhaitons piloter les LEDs *PB6* et *PB7* de la carte à l'aide du bouton *PB0*. 
On utilisera une interruption pour réaliser cette fonction.

On doit réaliser le changement d'état des LEDs sur le front montant et descendant de *PB0*.

A l'aide du registre du microcontrôleur (stm32l1xx.h), on trouve que c'est `EXTI_Trigger` qui défini l'activation de l'interruption en fonction du front que l'on veut : 
Front Descendant : _EXTI_Trigger_Falling_.
Front Montant : _EXTI_Trigger_Rising_.
Front Montant/Descendant : _EXTI_Trigger_Rising_Falling_.

On utilise la fonction `IRQ_EXTI0_Config` pour configurer l'interruption :
[source,c]
----
void IRQ_EXTI0_Config()
{
    // Configure GPIO pour l'Interrupteur
    /* Activer GPIOA */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);

    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode = GPIO_Mode_IN;
    gpio_a.GPIO_Pin = GPIO_Pin_0; // Pin 0
    GPIO_Init(GPIOA,&gpio_a);

    /* Activer SYSCFG sur APB2
     * pour permettre l'utilisation des interruptions externes */
    RCC_APB2PeriphClockCmd (RCC_APB2Periph_SYSCFG,ENABLE);
    /* Declarer PA0 comme source d'interruption */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);
    /* Param. des signaux qui déclencheront l'appel de EXTI0_IRQHandler()
     * autrement dit on paramètre les signaux associes a la "ligne 0"
     * ici : sur front montant & descendant ("EXTI_Trigger_Rising_Falling")     */
    EXTI_InitTypeDef EXTI0_params;
    EXTI_StructInit(&EXTI0_params);
    EXTI0_params.EXTI_Line = EXTI_Line0;
    EXTI0_params.EXTI_LineCmd = ENABLE;
    EXTI0_params.EXTI_Trigger = EXTI_Trigger_Rising_Falling;

    EXTI_Init(&EXTI0_params);

    /* Activer l'interruption dans le NVIC */
    NVIC_InitTypeDef nvic;
    NVIC_Init(&nvic);
    nvic.NVIC_IRQChannel = EXTI0_IRQn;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
----

Une fois l'interruption configurée, il s'agit maintenant de définir ce qu'elle réalisera.
La fonction `EXTI0_IRQHandler` est faite pour cela : elle s'execute quand l'interruption a lieu.

On souhaite donc inverser l'état d'une DEL que l'on aura choisie. `GPIO_ToggleBits` est la fonction du GPIO qui permet d'inverser l'état d'un pin. Il est configuré en fonction du coté (A ou B) et du numéro de la pin.
[source,c]
----
// callback pour l'interruption externe EXTI0_IRQ
void EXTI0_IRQHandler(void) // Le code a executer quand il y a interruption.
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET) //Permet de faire une seule fois l'interruption au lieu de la répéter.
    {
        /* Clear the EXTI line 0 pending bit (enlève le flag) */
        EXTI_ClearITPendingBit(EXTI_Line0);
        GPIO_ToggleBits(GPIOB,GPIO_Pin_7); // Inverse état du pin 7 du coté B.
        GPIO_ToggleBits(GPIOB,GPIO_Pin_6); // Inverse état du pin 6 du coté B.
    }
}
----
Ici, le if évite que l'interruption se réalise plusieurs fois d'affilé, par exemple dans le cas du rebond d'un bouton.

Avec cette interruption, on inversera les états des LEDs PB6 et PB7 sur la pression et la relève du bouton.

Pour que les états des LEDs soient inversés l'un par rapport à l'autre, il suffit de définir l'état de base d'une des LEDs comme étant allumé :
On ajoute, avant la boucle du main, la fonction `GPIO_SetBits` qui se paramètre comme `GPIO_ToggleBits`. Cette fonction "set" à 1 le pin configuré, ce qui revient à alimenter la DEL.

La fonction main de cet exercice devrait donc ressembler à cela :
[source,c]
.Fonction Main
------
int main(void)
{
    // # LED sur PB7 et PB6
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT; // Sortie tout-ou-rien
    gpio_b.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_6; // Pin choisi : 7 et 6
    GPIO_Init(GPIOB,&gpio_b);
    /* allumer la LED*/
    GPIO_SetBits(GPIOB,GPIO_Pin_7); // Set à 1 le pin 7 du coté B. La DEL est allumée.
    // configuration de l'interruption
    IRQ_EXTI0_Config();

    while(1) {
        // Rien car on attend l'interruption
    }
}
------

=== Interruptions Périodique

Si le premier exercice ordonnait une interruption sur l'appuie d'un bouton (donc une commande extérieure), ce second exercice se basera sur l'horloge du microcontrôleur pour ordonner l'interruption.

On souhaite faire clignoter la DEL toutes les 500ms.
On va utiliser le *Timer 2* de la carte pour mesurer ce temps.

[source,c]
.TIM2_IRQ_Config
------
void TIM2_IRQ_Config()
{
    /*Activer TIM2 sur APB1 */  
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    TIM_TimeBaseInitTypeDef timer_2;
    TIM_TimeBaseStructInit(&timer_2);
    timer_2.TIM_Prescaler = 16000-1;
    timer_2.TIM_Period = 500-1;
    TIM_TimeBaseInit(TIM2,&timer_2);
    TIM_SetCounter(TIM2,0);
    TIM_Cmd(TIM2, ENABLE); // Active le Timer

    /* Associer une interruption a TIM2 */
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

    NVIC_InitTypeDef nvic;
    /* Configuration de l'interruption */
    nvic.NVIC_IRQChannel = TIM2_IRQn;
    nvic.NVIC_IRQChannelPreemptionPriority = 0; 
    nvic.NVIC_IRQChannelSubPriority = 1;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
------

La fréquence du microcontrôleur étant de 16Mhz, on choisi un prescaler de 16000 : `TIM_Period` s'incrémentera toutes les ms.
Voulant une interruptions toutes les 500ms, il suffira de définir la valeur de `TIM_Period` à 500.

Le code de l'interruption est identique à celle des interruptions extérieures, au détail près qu'elle s'appelle `TIM2_IRQHandler`.

[source,c]
.TIM2_IRQHandler
------
void TIM2_IRQHandler() {
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
        GPIO_ToggleBits(GPIOB, GPIO_Pin_7); // Inversion du pin 7
    }
}
------

==== Changement de Fréquence

On nous demande cette fois-ci une fréquence de 44kHz.
On décide cette fois-ci de mettre le prescaler à 0 (`TIM_Prescaler` = 0).
Fréquence voulue = 44 kHz ; Fréquence du CPU = 16 MHz.

Thorloge = (TIM_Period+1)*(TIM_Prescaler+1)/16e6
1/44e3 = TIM_Period/16e6 <=> TIM_Period = 16e6/44e3 = *363.6* (on arrondira au supérieur)

Une fois reconfiguré, on observe sur l'oscilloscope que la fréquence observée n'est pas 44kHz, mais 22kHz : ramené en période, 44kHz = 22.7us et 22kHz = 45.5us.
Une période de la DEL est quand elle a été allumée et éteinte une fois.
Hors, le code actuel fait que tous les 22.7us (44kHz), on inverse l'état de la DEL.
Ainsi, 22.7us + 22.7us = 45.5us, soit 22kHz.

Pour remédier à ce problème, on peut par exemple réduire de moitié la valeur de `timer_2.TIM_Period`, soit 182 au lieu de 364.

<<<

== Générer un courant sinusoïdal

Maintenant que l'on sait comment réaliser des interruptions périodiquement, on veut générer une tension sinusoïdale sur le pin *PA4* de la carte.
Cependant, le microcontrôleur n'est pas capable de lui-même de faire ce signal, c'est pourquoi nous allons l'aider en calculant en amont les valeurs qu'il générera.

=== Le sinus

Avant toute chose, nous avons besoin de la bibliothèque *math* (`math.h`) pour utiliser le sinus. 

Nous stockerons les valeurs du sinus dans un tableau nommé _Tension_ que l'on définira à l'aide de la fonction `malloc`.
Malloc permet d'allouer à une variable un espace qui sera calculé en fonction du type de variable présente dedans :
[source,c]
------
Tension = malloc(100*sizeof(float));
------
Tension fait maintenant la taille de 100 valeurs du type float.
Ce tableau devra être déclaré globalement pour que l'interruption puisse s'en servir.

Les préparations maintenant faites, il faut maintenant calculer le sinus.

L'équation du sinus est :
Tension = 511 * sin(2*3.14159*k/100) + 2047;
où k est un incrément qui ira de 0 à 99 (100 valeurs).

[source,c]
.Calcul du sinus
------
#include <math.h>
float* Tension;

int main()
{
    Tension = malloc(100*sizeof(float));
    for(int k=0;k<100;k++) {
        Tension[k] = 511 * sin(2*3.14159*k/100) + 2047;
    }
}
------

Le microcontrôleur ne peut générer des tensions qu'entre 0 et 3V.
On choisi donc de décaler la valeur moyenne du sinus de +1.5V ; les valeurs seront comprises dans l'amplitude valide.

Le convertisseur analogique à numérique de la carte fonctionne sur 12 bits : 2^12 = 4096 valeurs.
Donc pour 3V, le convertisseur est égal à 4095 ; pour 1.5V (la valeur moyenne), 2047 ; et pour 0V, 0.
C'est pour cela que l'on ajoute 2047 à l'équation, pour centrer le sinus sur 1.5V.

* La valeur minimale du sinus est donc :
2047 - 511 = *1536*, ce qui donne une tension en sortie du convertisseur de *1.25V*.

* La valeur minimale du sinus est donc :
2047 + 511 = *2558*, ce qui donne une tension en sortie du convertisseur de *1.87V*.

J'ai utilisé un produit en croix pour convertir les valeurs du convertisseurs en tension.

=== DAC & sinus

Maintenant que le sinus est calculé et stocké dans la variable _Tension_, il est temps de générer le signal en sortie de la carte.
Pour ce faire, on ré-emploie une fonction du code du précédent exercice, *TIM2*.
On devra également utiliser le convertisseur Digital à Analogique (*DAC*).

==== Configuration du TIMER

Nous n'avons pas besoin de toucher à la configuration précédente de *TIM2*. Le prescaler (`_timer_2.TIM_Prescaler`) et la période (`timer_2.TIM_Period`) restent les mêmes puisque l'on garde la fréquence de 44kHz.

La seule partie qui change est l'interruption en elle même :
[source,c]
------
void TIM2_IRQHandler() {
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
        GPIO_ToggleBits(GPIOB, GPIO_Pin_7); // Débugage
        DAC1_Set(Tension[n%100]); // Converti la valeur en tension 
        // On ne dépasse pas 99 valeurs : à n = 100, n%100 = 0
        n++; // Incrémentation
    }
}
------
On déclarer en variable globale _n_, l'incrémenteur de _Tension_.

==== Configuration du DAC

Le *DAC* est un convertisseur Digital à Analogique.
Dans ce TD, il est nécessaire pour convertir les valeurs du sinus en une tension.

[source,c]
.DAC1_Config
------
void DAC1_Config()
{
    /*Activer GPIOA sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    /* Configurer PA4 en mode analogique*/
    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode  = GPIO_Mode_AN; // Mode Analogique
    gpio_a.GPIO_Pin = GPIO_Pin_4;     // Sortie sur PIN 4
    GPIO_Init(GPIOA, &gpio_a);

    /*Activer DAC sur APB1 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
    /* Configurer DAC1 avec paramètres par défaut */
    DAC_InitTypeDef dac_1;
    DAC_StructInit(&dac_1);
    DAC_Init(DAC_Channel_1, &dac_1);
    /* Activer DAC1 */
    DAC_Cmd(DAC_Channel_1, ENABLE);
}
------

Maintenant que le DAC est configuré, il ne reste plus qu'à convertir les valeurs et à les émettre.
Le DAC utilise deux fonctions pour convertir puis générer une tension :
- `DAC_SetChannel1Data` et initialise la tension.
- `DAC_SoftwareTriggerCmd` émet la valeur.

[source,c]
------
void DAC1_Set(uint16_t value)
{
    DAC_SetChannel1Data(DAC_Align_12b_R , value);
    DAC_SoftwareTriggerCmd(DAC_Channel_1 , ENABLE);
}
------

=== Écoute au Casque

Il n'est pas possible de brancher directement un casque à notre microcontrôleur. Le casque fonctionne avec des tensions comprises entre -1.5V et 1.5V, or, la carte n'est pas capable de générer ces valeurs négatifs. 
En réalisant un pont diviseur de tension et en y ajoutant un condensateur, on peut abaisser la tension moyenne de 1.5V à 0V.
Ainsi, on peut brancher le casque au microcontrôleur par l'intermédiaire.

Une fois que l'on branche un casque sur le circuit, le son entendu n'est pas un DO, mais une note plus aiguë. 
Cela s'explique par le casque qui a besoin qu'on l'attaque avec une tension supérieure à celle fournie en sortie du condensateur. 
Ce manque de tension provoque une perturbation du signal généré par la carte, et donc crée des fréquences parasites qui perturbent l'écoute :
Le son entendu est plus aiguë que ce que l'on devrait avoir.

En mettant un montage suiveur entre le condensateur et le casque, l'AOP joue le role d'une alimentation qui va fournir un signal de meilleur qualité au casque, permettant d'entendre le DO.

<<<

== Le Mini-Synthétiseur

A l'aide des fonctions précédemment utilisées, cet exercice demande que l'on émette du son en fonction 

Dans un premier temps,  l'on modifie la fréquence du DAC sur l'appuie du bouton *PA0*. 
Chacune de ces fréquences correspondent à une note de musique, ainsi chaque pression changera la note produite.

[cols="2b,^,^,^,^,^,^,^,^"]
|===
|Note|Do|Re|Mi|Fa|Sol|La|Si|Do
|Fréquence|262|294|330|350|392|440|494|524
|Valeur DAC|611|544|484|458|408|363|323|306
|===

Ces valeurs sont initialisée dans une variable nommée _note_periode_.
[source,c]
------
unsigned int note_periode[8] = {611,544,484,458,408,363,323,306};
------

Comme vu dans la première partie, on configure le GPIO pour faire fonctionner le bouton *PA0*. 
Cette fois-ci, on n'utilisera pas une interruption pour réaliser l'action du bouton car cela causerait des problèmes lors de l'execution.
On place dans le while :
[source,c]
------
int switch_status = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
if (switch_status == Bit_SET && prev_switch_status == 0)
{
	interrupteur++; // Nb d'appuie sur l'interrupteur
	TIM_Cmd(TIM2, DISABLE); // Désactive le Compteur
	TIM_SetCounter(TIM2, 0); // Reinitialise le Compteur
	TIM_TimeBaseInitTypeDef timer_2;
	TIM_TimeBaseStructInit(&timer_2);
	timer_2.TIM_Prescaler = 0; 
	timer_2.TIM_Period = note_periode[interrupteur%8]; // Change valeur de la période du timer
    // A 8, on redescend à 0
	TIM_TimeBaseInit(TIM2, &timer_2);
	TIM_Cmd(TIM2, ENABLE);
}
prev_switch_status = switch_status; // Stock l'état n dans une variable n-1.
------

Comme tout à l'heure 

=== Signal sinus

[source,c]
------
void buildSinus() {
	for (int k = 0; k < 100; k++) {
		T[k] = 511 * sin(2 * 3.14159 * k / 100) + 2047;
	}
}
------

=== Signal en dent de scie

[source,c]
------
void buildSawTooth() {
    for(int k=0; k<100;k++) {
        T[k] = 2047-511 + (k*1022/100);
    }
}
------

=== Signal en triangle

[source,c]
------
void buildTriangle() {
	int k;
    for(int k=0; k<100/2;k++) {
        T[k] = 2047-511 + (k*1022*2/100);
    }
    for(; k<100;k++) {
        T[k] = 2047 + 511 -((k-100/2)*1022*2/100);
    }
}
------

Le signal qui me parait le plus agressif à l'écoute est le second, c'est à dire en dent de scie.




<<<

== Mini Projet : Filtrage Numérique d'un Signal

Cette ultime partie du TP transformera le microcontrôleur en carte son.
On devra être capable, par exemple, d'atténuer les aiguës ou les graves, d'augmenter le volume sonore en sortie du montage...

Après avoir réalisé le montage qui aura en entrée la sortie JACK du PC et en sortie le casque, on compare le signal en entrée et en sortie.


Les fonctions primordiales de ce programme, `Get_Adc_quickly` et `DAC1_Set_Quickly`, sont écrites en *Bare Metal*. Si ces dernières étaient écrite en langage bibliothèque (c'est à dire en utilisant la bibliothèque de )

==== Get_Adc_quickly

Cette fonction est utilisée pour convertir le signal arrivant du PC en des valeurs pour la carte.
[source,C]
----
uint16_t Get_Adc_Quickly() {
    ADC1->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    while((ADC1->SR & ADC_FLAG_EOC) == 0) ;
    return (uint16_t) ADC1->DR;
}
----

#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
__IO uint32_t CR2;          /*!< ADC control register 2,                      Address offset: 0x08 */
__IO uint32_t SR;           /*!< ADC status register,                         Address offset: 0x00 */
__IO uint32_t DR;           /*!< ADC regular data register,                   Address offset: 0x58 */
#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!< Start Conversion of regular channels */
#define ADC_FLAG_EOC                               ((uint16_t)0x0002)

[%header,cols=",^1,2"]
|===
|Nom|Offset de l'adresse|Registre
|CR2|0x08|ADC control register 2
|SR|0x00|ADC status register
|DR|0x58|ADC regular data register
|===

==== DAC1_Set_Quickly

Cette fonction est l'inverse Get_Adc_quickly : elle converti les valeurs traité par la carte en une tension pour le casque.

Diminuer adc revient à diminuer le volume en sortie

[source,C]
----
void DAC1_Set_Quickly(uint16_t value) {
	static __IO uint32_t tmp = (uint32_t)DAC_BASE + (uint32_t)0x00000008 + DAC_Align_12b_R;
	*(__IO uint32_t *) tmp = value;
}
----

#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
#define DAC_Align_12b_R                    ((uint32_t)0x00000000)


=== Passe Bas




=== Compresseur Audio

Le but d'un compresseur audio est d'égaliser les sons qu'il a à traité : les sons les plus forts sont atténués tandis que les plus faibles sont amplifiés.



<<<

== Annexe [[id,annexe]]

=== Exercice 1

[source,c]
------
#include "stm32l1xx.h"

void IRQ_EXTI0_Config();

int main(void)
{
    // # LED sur PB7
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    /* Configurer PB7 comme sortie tout-ou-rien */
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT;
    gpio_b.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_6;
    GPIO_Init(GPIOB,&gpio_b);
    /* allumer la LED*/
    GPIO_SetBits(GPIOB,GPIO_Pin_7);
    // configuration de l'interruption
    IRQ_EXTI0_Config();

    while(1) {
    }
}

// callback pour l'interruption externe EXTI0_IRQ
void EXTI0_IRQHandler(void) // Le code a executer quand il y a interruption.
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET) // Permet de faire une seule fois l'interruption au lieu de la répéter.
    {
        /* Clear the EXTI line 0 pending bit (enlève le flag) */
        EXTI_ClearITPendingBit(EXTI_Line0);
        GPIO_ToggleBits(GPIOB,GPIO_Pin_7); // Inverse état du pin 7
        GPIO_ToggleBits(GPIOB,GPIO_Pin_6); // Inverse état du pin 6
    }
}

// ### EXTI0 sur PA0
// Configuration
void IRQ_EXTI0_Config()
{
    // # Interrupteur
    /* Activer GPIOA sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
    /* Configurer PB7 comme entree tout-ou-rien */
    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode = GPIO_Mode_IN;
    gpio_a.GPIO_Pin = GPIO_Pin_0;
    GPIO_Init(GPIOA,&gpio_a);

    /* Activer SYSCFG sur APB2
     * pour permettre l'utilisation des interruptions externes */
    RCC_APB2PeriphClockCmd (RCC_APB2Periph_SYSCFG,ENABLE);
    /* Declarer PA0 comme source d'interruption */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);
    /* Param. des signaux qui declencheront l'appel de EXTI0_IRQHandler()
     * autrement dit on parametre les signaux associes a la "ligne 0"
     * ici : sur front montant ("Trigger_Rising")
     */
    EXTI_InitTypeDef EXTI0_params;
    EXTI_StructInit(&EXTI0_params);
    EXTI0_params.EXTI_Line = EXTI_Line0;
    EXTI0_params.EXTI_LineCmd = ENABLE;
    EXTI0_params.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
// Front Descendant : EXTI_Trigger_Falling
// Front Montant : EXTI_Trigger_Rising
// Front : EXTI_Trigger_Rising_Falling

    EXTI_Init(&EXTI0_params);

    /* Activer l'interruption dans le NVIC */
    NVIC_InitTypeDef nvic;
    NVIC_Init(&nvic);
    nvic.NVIC_IRQChannel = EXTI0_IRQn;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
------

<<<

=== Exercice 2
[source,c]
------
#include "stm32l1xx.h"

#include <math.h>
#define pi 3.141592
#include <stdlib.h>

void TIM2_IRQ_Config();

int main(void)
{
    TIM2_IRQ_Config();

    // # LED sur PB7
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    /* Configurer PB7 comme sortie tout-ou-rien */
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT;
    gpio_b.GPIO_Pin = GPIO_Pin_7;
    GPIO_Init(GPIOB,&gpio_b);

    while(1) { }
}

// callback pour l'interruption periodique associee a TIM2
void TIM2_IRQHandler() {
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
        GPIO_ToggleBits(GPIOB, GPIO_Pin_7); // Inversion du pin 7
    }
}

// ### TIMER 2 + IRQ a 500 ms
// Configuration Timer 2 a 500 ms
// avec emission d'IRQ : execute periodiquement TIM2_IRQHandler()
void TIM2_IRQ_Config()
{
    /*Activer TIM2 sur APB1 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    /* Configurer TIM2 a 500 ms */
    TIM_TimeBaseInitTypeDef timer_2;
    TIM_TimeBaseStructInit(&timer_2);
    timer_2.TIM_Prescaler = 0; // prescaler et Période ont au final le même résultat
    timer_2.TIM_Period = 364-1; // Cependant, on utilise prescaler pour compter le temps et Période pour mesurer le temps.
// Fhorloge = 44 000 Hz ; CPU = 16*10^6
// Thorloge = Modificateur/16x10^6 <=> 1/44000 = TIM_Period/16x10^6 <=> TIM_Period = 16x10^6/44000 = 363.6 (on arrondira au supérieur)

// On retrouve 2kHz, la moitié de la fréquence prévue, à cause du fonctionnement de l'horloge
    TIM_TimeBaseInit(TIM2,&timer_2);
    TIM_SetCounter(TIM2,0);
    TIM_Cmd(TIM2, ENABLE);

    /* Associer une interruption a TIM2 */
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

    NVIC_InitTypeDef nvic;
    /* Configuration de l'interruption */
    nvic.NVIC_IRQChannel = TIM2_IRQn;
    nvic.NVIC_IRQChannelPreemptionPriority = 0;
    nvic.NVIC_IRQChannelSubPriority = 1;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}
------

<<<

=== Exercice 3
[source,c]
------
#include "stm32l1xx.h"

#include <math.h>

void DAC1_Config();
void DAC1_Set(uint16_t value);

void TIM2_IRQ_Config();

float* T;
int n=0;

int main(void)
{
    TIM2_IRQ_Config();
    DAC1_Config();

    // # LED sur PB7
    /* Activer GPIOB sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);
    /* Configurer PB7 comme sortie tout-ou-rien */
    GPIO_InitTypeDef gpio_b;
    GPIO_StructInit(&gpio_b);
    gpio_b.GPIO_Mode = GPIO_Mode_OUT;
    gpio_b.GPIO_Pin = GPIO_Pin_7;
    GPIO_Init(GPIOB,&gpio_b);

    T = malloc(100*sizeof(float));
    for(int k=0;k<100;k++)
    {
        T[k] = 511 * sin(2*3.14159*k/100) + 2047;

    }


    while(1) {

    }
}

// callback pour l'interruption periodique associee a TIM2
void TIM2_IRQHandler() {
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
        GPIO_ToggleBits(GPIOB, GPIO_Pin_7);
        DAC1_Set(T[n%100]);
        n++;
    }
}

// ### TIMER 2 + IRQ a 500 ms
// Configuration Timer 2 a 500 ms
// avec emission d'IRQ : execute periodiquement TIM2_IRQHandler()
void TIM2_IRQ_Config()
{
    /*Activer TIM2 sur APB1 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    /* Configurer TIM2 a 500 ms */
    TIM_TimeBaseInitTypeDef timer_2;
    TIM_TimeBaseStructInit(&timer_2);
    timer_2.TIM_Prescaler = 0;
    timer_2.TIM_Period = 363;
    TIM_TimeBaseInit(TIM2,&timer_2);
    TIM_SetCounter(TIM2,0);
    TIM_Cmd(TIM2, ENABLE);

    /* Associer une interruption a TIM2 */
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

    NVIC_InitTypeDef nvic;
    /* Configuration de l'interruption */
    nvic.NVIC_IRQChannel = TIM2_IRQn;
    nvic.NVIC_IRQChannelPreemptionPriority = 0;
    nvic.NVIC_IRQChannelSubPriority = 1;
    nvic.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&nvic);
}


// ### DAC1 (DAC Channel 1) sur PA4
// Configuration
void DAC1_Config()
{
    /*Activer GPIOA sur AHB */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    /* Configurer PA4 en mode analogique*/
    GPIO_InitTypeDef gpio_a;
    GPIO_StructInit(&gpio_a);
    gpio_a.GPIO_Mode  = GPIO_Mode_AN;
    gpio_a.GPIO_Pin = GPIO_Pin_4;
    GPIO_Init(GPIOA, &gpio_a);

    /*Activer DAC sur APB1 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
    /* Configurer DAC1 avec parametres par defaut */
    DAC_InitTypeDef dac_1;
    DAC_StructInit(&dac_1);
    DAC_Init(DAC_Channel_1, &dac_1);
    /* Activer DAC1 */
    DAC_Cmd(DAC_Channel_1, ENABLE);
}

void DAC1_Set(uint16_t value)
{
    DAC_SetChannel1Data( DAC_Align_12b_R, value );
    DAC_SoftwareTriggerCmd( DAC_Channel_1, ENABLE );

}

------

<<<

=== Exercice 4
[source,c]
------
#include "stm32l1xx.h"

#include <math.h>
#include <stdlib.h>

void DAC1_Config();
void DAC1_Set(uint16_t value);
void GPIOA_PA0_Config();

void TIM2_IRQ_Config();

unsigned int note_periode[8] = {611,544,484,458,408,363,323,306};


float* T;
int n = 0;
int interrupteur = 0;

void buildSawTooth() {
    for(int k=0; k<100;k++) {
        T[k] = 2047-511 + (k*1022/100);
    }
}
void buildTriangle() {
	int k;
        for(int k=0; k<100/2;k++) {
            T[k] = 2047-511 + (k*1022*2/100);
        }
        for(; k<100;k++) {
            T[k] = 2047 + 511 -((k-100/2)*1022*2/100);
        }
}
void buildSinus() {
	for (int k = 0; k < 100; k++) {
		T[k] = 511 * sin(2 * 3.14159 * k / 100) + 2047;
	}
}

int main(void) {
	TIM2_IRQ_Config();
	DAC1_Config();
	GPIOA_PA0_Config();

	// # LED sur PB7
	/* Activer GPIOB sur AHB */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
	/* Configurer PB7 comme sortie tout-ou-rien */
	GPIO_InitTypeDef gpio_b;
	GPIO_StructInit(&gpio_b);
	gpio_b.GPIO_Mode = GPIO_Mode_OUT;
	gpio_b.GPIO_Pin = GPIO_Pin_7;
	GPIO_Init(GPIOB, &gpio_b);

	T = malloc(100 * sizeof(float));

	//buildSinus();
	//buildSawTooth();
	//buildTriangle();

	GPIOA_PA0_Config();

	int prev_switch_status = 0;

	while (1) {
		int switch_status = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
		if (switch_status == Bit_SET && prev_switch_status == 0) {
			// A REMPLIR : ce que l'on doit executer si le bouton est appuye
			interrupteur++; // Nb d'appuie sur l'interrupteur
			TIM_Cmd(TIM2, DISABLE);
			TIM_SetCounter(TIM2, 0);
			TIM_TimeBaseInitTypeDef timer_2;
			TIM_TimeBaseStructInit(&timer_2);
			timer_2.TIM_Prescaler = 0;
			timer_2.TIM_Period = note_periode[interrupteur%8]; // A 8, on redescend à 0
			TIM_TimeBaseInit(TIM2, &timer_2);
			TIM_Cmd(TIM2, ENABLE);
		}
		prev_switch_status = switch_status;
	}
}

// callback pour l'interruption periodique associee a TIM2
void TIM2_IRQHandler() {
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		GPIO_ToggleBits(GPIOB, GPIO_Pin_7);
		DAC1_Set(T[n % 100]);
		n++;
	}
}

// ### TIMER 2 + IRQ a 500 ms
// Configuration Timer 2 a 500 ms
// avec emission d'IRQ : execute periodiquement TIM2_IRQHandler()
void TIM2_IRQ_Config() {
	/*Activer TIM2 sur APB1 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	/* Configurer TIM2 a 500 ms */
	TIM_TimeBaseInitTypeDef timer_2;
	TIM_TimeBaseStructInit(&timer_2);
	timer_2.TIM_Prescaler = 0;
	timer_2.TIM_Period = 363;
	TIM_TimeBaseInit(TIM2, &timer_2);
	TIM_SetCounter(TIM2, 0);
	TIM_Cmd(TIM2, ENABLE);

	/* Associer une interruption a TIM2 */
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	NVIC_InitTypeDef nvic;
	/* Configuration de l'interruption */
	nvic.NVIC_IRQChannel = TIM2_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0;
	nvic.NVIC_IRQChannelSubPriority = 1;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);
}

// ### DAC1 (DAC Channel 1) sur PA4
// Configuration
void DAC1_Config() {
	/*Activer GPIOA sur AHB */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	/* Configurer PA4 en mode analogique*/
	GPIO_InitTypeDef gpio_a;
	GPIO_StructInit(&gpio_a);
	gpio_a.GPIO_Mode = GPIO_Mode_AN;
	gpio_a.GPIO_Pin = GPIO_Pin_4;
	GPIO_Init(GPIOA, &gpio_a);

	/*Activer DAC sur APB1 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
	/* Configurer DAC1 avec parametres par defaut */
	DAC_InitTypeDef dac_1;
	DAC_StructInit(&dac_1);
	DAC_Init(DAC_Channel_1, &dac_1);
	/* Activer DAC1 */
	DAC_Cmd(DAC_Channel_1, ENABLE);
}

void DAC1_Set(uint16_t value) {
	DAC_SetChannel1Data( DAC_Align_12b_R, value);
	DAC_SoftwareTriggerCmd( DAC_Channel_1, ENABLE);

}

void GPIOA_PA0_Config() {
	// switch PA0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	GPIO_InitTypeDef switch_PA;
	GPIO_StructInit(&switch_PA);
	switch_PA.GPIO_Mode = GPIO_Mode_IN;
	switch_PA.GPIO_Pin = GPIO_Pin_0;
	GPIO_Init(GPIOB, &switch_PA);
}

------
